name: Auto Release

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build_and_publish:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository (fetch all tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine next version and changed files
        id: version
        run: |
          set -euo pipefail

          # Determine latest V* tag (can be Vx or Vx.y)
          LATEST_TAG=$(git tag -l "V*" | sort -V | tail -n1 || true)

          # For manual releases (workflow_dispatch), increment X and reset Y to 0
          # For automatic releases (push), increment Y on the current X
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            # Manual release - increment X
            if [ -z "${LATEST_TAG}" ]; then
              NEXT_X=1
              NEXT_TAG="V1"
            else
              # Extract X from the tag (strip V and anything after . if present)
              TAG_WITHOUT_V=${LATEST_TAG#V}
              X_VALUE=$(echo "${TAG_WITHOUT_V}" | cut -d'.' -f1)
              if ! printf '%s\n' "$X_VALUE" | grep -Eq '^[0-9]+$'; then
                NEXT_X=1
              else
                NEXT_X=$((X_VALUE + 1))
              fi
              NEXT_TAG="V${NEXT_X}"
            fi
          else
            # Automatic release - increment Y on current X
            if [ -z "${LATEST_TAG}" ]; then
              # No tags yet - start with V1.1 for first automatic release
              NEXT_TAG="V1.1"
            else
              # Check if latest tag is in Vx or Vx.y format
              if [[ "${LATEST_TAG}" =~ ^V[0-9]+\.[0-9]+$ ]]; then
                # It's already Vx.y format - increment Y
                TAG_WITHOUT_V=${LATEST_TAG#V}
                X_VALUE=$(echo "${TAG_WITHOUT_V}" | cut -d'.' -f1)
                Y_VALUE=$(echo "${TAG_WITHOUT_V}" | cut -d'.' -f2)
                
                if ! printf '%s\n' "$Y_VALUE" | grep -Eq '^[0-9]+$'; then
                  NEXT_Y=1
                else
                  NEXT_Y=$((Y_VALUE + 1))
                fi
                NEXT_TAG="V${X_VALUE}.${NEXT_Y}"
              else
                # It's Vx format - this must be from a manual release
                # Start auto releases for this X with .1
                TAG_WITHOUT_V=${LATEST_TAG#V}
                X_VALUE=${TAG_WITHOUT_V}
                NEXT_TAG="V${X_VALUE}.1"
              fi
            fi
          fi

          RELEASE_TAG="${NEXT_TAG}"
          ZIP_FILE="the-fun-guns-${RELEASE_TAG}.zip"

          echo "Determined next tag: ${RELEASE_TAG}"
          echo "RELEASE_TAG=${RELEASE_TAG}" >> $GITHUB_ENV
          echo "ZIP_FILE=${ZIP_FILE}" >> $GITHUB_ENV

          # Find the last user-engaged release (Vx without .y) for changelog purposes
          LAST_USER_RELEASE=$(git tag -l "V[0-9]*" | grep -E '^V[0-9]+$' | sort -V | tail -n1 || true)

          # For change detection, we compare with the last tag (for automatic releases)
          # or with the last user release (for manual releases)
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            # Manual release: compare with last user release
            COMPARE_TAG="${LAST_USER_RELEASE}"
          else
            # Automatic release: compare with last tag (any type)
            COMPARE_TAG="${LATEST_TAG}"
          fi

          # Get changed files
          if [ -z "${COMPARE_TAG}" ]; then
            CHANGED=$(git ls-files -z | tr '\0' '\n')
          else
            CHANGED=$(git diff --name-only -z "$COMPARE_TAG" HEAD | tr '\0' '\n')
          fi

          # Build release body based on trigger type
          RELEASE_BODY_FILE=release_body.txt
          
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            # Manual trigger - create changelog with commit messages and contributors
            # Since the last user-engaged release (Vx)
            {
              echo "Changelog since ${LAST_USER_RELEASE:-the beginning}:"
              echo ""
              if [ -z "${CHANGED}" ]; then
                echo "(no file changes detected)"
              else
                # Get unique file changes with their latest commit messages
                echo "### File Changes:"
                while IFS= read -r -d '' file; do
                  if [ -n "$file" ]; then
                    # Get commit messages for this file since the last user release
                    if [ -z "${LAST_USER_RELEASE}" ]; then
                      COMMIT_MSG=$(git log --oneline --follow -1 -- "$file" | sed 's/^[^ ]* //')
                    else
                      COMMIT_MSG=$(git log --oneline --follow -1 "${LAST_USER_RELEASE}"..HEAD -- "$file" | sed 's/^[^ ]* //')
                    fi
                    if [ -n "$COMMIT_MSG" ]; then
                      echo "- **$file**: $COMMIT_MSG"
                    fi
                  fi
                done < <(printf '%s' "$CHANGED" | tr '\n' '\0')
                echo ""
                
                # Get unique contributors since last user release
                echo "### Contributors:"
                if [ -z "${LAST_USER_RELEASE}" ]; then
                  CONTRIBUTORS=$(git log --pretty=format:"%an" HEAD | sort -u)
                else
                  CONTRIBUTORS=$(git log --pretty=format:"%an" "${LAST_USER_RELEASE}"..HEAD | sort -u)
                fi
                if [ -z "$CONTRIBUTORS" ]; then
                  echo "- (no contributors)"
                else
                  echo "$CONTRIBUTORS" | while read -r contributor; do
                    echo "- $contributor"
                  done
                fi
              fi
            } > "${RELEASE_BODY_FILE}"
          else
            # Push trigger - original format
            {
              echo "Changed files included in ${RELEASE_TAG}:"
              echo ""
              if [ -z "${CHANGED}" ]; then
                echo "(no file changes detected)"
              else
                printf '%s\n' "${CHANGED}" | sed 's/^/- /'
              fi
              echo ""
              echo "Generated by GitHub Actions."
            } > "${RELEASE_BODY_FILE}"
          fi
          
          echo "RELEASE_BODY_FILE=${RELEASE_BODY_FILE}" >> $GITHUB_ENV

      - name: Create ZIP artifact (exclude docs, DBs, git metadata, VS files, workflows)
        run: |
          rm -f "${ZIP_FILE}"
          zip -r "${ZIP_FILE}" . \
            -x "*.md" \
            -x "LICENSE" \
            -x "*.db" \
            -x ".vs/*" \
            -x ".gitignore" \
            -x ".git/*" \
            -x ".github/*" \
            -x "*.yaml"

      - name: Create git tag and push
        env:
          RELEASE_TAG: ${{ env.RELEASE_TAG }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git tag "${RELEASE_TAG}"
          git push origin "${RELEASE_TAG}"

      - name: Determine release type
        id: release_type
        run: |
          # Manual dispatch = full release; push = prerelease
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            echo "IS_PRERELEASE=false" >> $GITHUB_ENV
          else
            echo "IS_PRERELEASE=true" >> $GITHUB_ENV
          fi

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          release_name: The Fun Guns ${{ env.RELEASE_TAG }}
          body_path: ${{ env.RELEASE_BODY_FILE }}
          draft: false
          prerelease: ${{ github.event_name != 'workflow_dispatch' }}
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}

      - name: Upload release asset (ZIP)
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ env.ZIP_FILE }}
          asset_name: ${{ env.ZIP_FILE }}
          asset_content_type: application/zip
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}
